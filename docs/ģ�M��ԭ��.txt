模M器原理

早期在 PC 上模M器的牛人，Marat Fayzullin 是其中之一。1997 年，他就已_l出 fMSX 模M器，K且以@篇文章 how to write a computer emulator(http://fms.komkon.org/EMUL8/HOWTO.html) 分享他的知R。中文翻g的W已不存在了，可惜。


下面是x後的整理：

V要：
什N可以被模M？
什N是 emulation，它跟 simulation 有什N不同？
模M有＠的硬w，是合法的幔
什N是直g式的模M器，跟g式的模M器有何不同？
我想一模M器，我暮伍_始？
我用哪一N程式Z言？
我哪难e可以得到想模M的硬w的Y？
做：
如何模M一 CPU？
如何存取被模M的w？
L期性的\作有哪些？
程式技巧：
如何最佳化 C 程式a？
什N是高低字序？
如何程式具可移植性？
楹挝乙模M化我的程式？
-------------------------------------------------------------------------
什N可以被模M？



基本上，任何|西有微理器在e面，就可模M。然，只有那些可以跑程式b置，我才有d趣模M。包括：
X
算C
[菲
大型
其他......
必特e]明，你可以模M任何X系y，即是事非常}s的系y（譬如 Amiga X），但是绦行率可能很低。



-------------------------------------------------------------------------
什N是 Emulation，它跟 Simulation 有什N不同？

Emulation 模Mb置炔康挠搀w，Simulation 是模Mb置炔康墓δ堋Ｅe例碚f，一程式模M小精`大型拥挠搀w，然後绦行【`的 ROM，就是 emulator。一小精`的 PC [颍就是 simulator。



-------------------------------------------------------------------------
模M有＠的硬w，是合法的幔

@是灰色地В只要你不是透^不合法的管道，拿到硬w的Y，就不`法。但是很清楚知道，跟模M器一起散延兄作嗟南到y ROM（例如 BIOS），是`法的。



-------------------------------------------------------------------------
什N是直g式的模M器，跟g式的模M器有何不同？

模M器有三NO的方式，@些O也可以混用，磉_到最好的效果。
直g式
模M器一位元又一位元的，挠wx取代a，然後解a，绦的捍嫫鳌⒂w、出入的命令。通用的演算法如下：
while (CPUIsRunning)
{
Fetch OpCode
Interpret OpCode
}

@NO的好是，容易除e，容易移植，容易同步（你只需要算^了多少 CPU L期，然後你模M的其他部份，跟 CPU 同步）。

@NO明@的弱c，就是绦行率很差。绦兄弊g花很多 CPU rg，你需要很快的X，才能有不e的绦兴俣取
oBg式
@N技g，就是把一支你要模M的系y的代a，g成你的X的的M合Z言。g的Y果，通常是一支你的X的普通绦n，不需要~外的工具就可以绦小ｌoBg，起砗苊篮茫但通常不可行。例如，你就o法oBg自我修改的代a，因檫@N代a只有绦r，才知道热菔鞘颤N。椴t解Q上述的}，或S需要混用直g器，或是Bgg器。
Bg式
Bg基本上跟oBg一樱但Bgl生在程式绦r。Bg是在绦械 CALL 或 JUMP r才g，取代一_始就g一整程式。榱嗽黾绦行率，@N技g常常Y合oBg。你可以x，Bg式金塔模M器的作者 Ardi，的@篇Bg白皮W到更多



-------------------------------------------------------------------------
我想一模M器，我暮伍_始？

想要一模M器，你必懂程式O，以及滴浑子。如果懂得M合Z言，更好。
x一N程式Z言
找到所有被模M硬w的所有Y
 CPU 模M，或是x用一F成的 CPU 模M程式
粗略的其他周硬w的模M，至少要一部分
在@r候，冉ǔe器，你可以和ＤM，z查程式绦械慕Y果。你也需要一被模M CPU 的M合Z言反Mg器。如果找不到F成的，就自己一。
著用你的模M器绦谐淌
用除e程式跟反Mg器，看看程式到底在贮N，然後根此修改你的模M器

-------------------------------------------------------------------------
我用哪一N程式Z言？

最常被用到是 C 跟M合Z言，各有缺c。
M合 Z言
+ 通用，可以a生速度快的程式a
+ 可以直接使用捍嫫鳎碛成浔荒M的捍嫫
+ 很多M合Z言指令，可以到被模M的M合Z言指令
- 程式是不可移植的，Q句f，你的模M器，不能在eN CPU 上跑
- 很y除e跟So
C Z言
+ 可移植性，所以可以在不同的作I系y上跑
+ 相θ菀壮e跟So
+ τ搀w的不同假O，可以很快的y
- 通常 C Z言的程式比M合Z言的程式慢
要模M器，λx竦恼Z言，t解得很透兀是^Ρ匾的。因槟M器的程式很}s，你要最佳化你的模M器，它跑得越快越好。X模M器程式，^Σ皇悄阍W程式Z言的０浮
-------------------------------------------------------------------------
我哪难e可以得到想模M的硬w的Y？

下列地方，你想去看一看：

W路新群M
comp.emulators.misc
@新群M，模M器一般的}。S多模M器作者，m然e面s音很多。如果要N}到@新群M，得先看 c.e.m FAQ 常}。
comp.emulators.game-consoles
跟 comp.emulators.misc 一樱不^@新群M，９ル[菲鞯哪M器。如果要N}到@新群M，得先看 c.e.m FAQ 常}。
comp.sys./emulated-system/
comp.sys.* 新群MA樱９ヌ囟ǖ碾X系y。你x@些新群M，可以得到有用的技gY料。典型的例子：

com.sys.msx                           MSX / MSX2 /  MSX2+ / TurboR X
comp.sys.sinclair                   Sinclair ZX80/ZX81/ZXSpectrum/QL
comp.sys.apple2                   Apple ][

如果要l}到@新群M，得先看 FAQ
alt.folklore.computers
rec.games.video.classic
FTP
 Console and Game Programming  
 Arcade Videogame Hardware  
 Computer History and Emulation 
WWW
Marat Fayzullin Homepage 
Arcade Emulation Programming Repository 
Emulation Programmer's Resource 
-------------------------------------------------------------------------
如何模M一 CPU？

首先，如果你需要模M一实 Z80 或 6502 CPU，你可以使用 Marat Fayzullin 所的 CPU 模M器 然有些限制。

δ切┫胍自己 CPU 模M核心，或是ζ渲械倪\作原理感性趣的人，我提供一用 C 的例架如下，在真正的做，你或S考]略^其中部份，或添加新的部份。




Counter=InterruptPeriod;
PC=InitialPC;

for(;;)
{
  OpCode=Memory[PC++];
  Counter-=Cycles[OpCode];

  switch(OpCode)
  {
    case OpCode1:
    case OpCode2:
    ...
  }

  if(Counter<=0)
  {
    /* Check for interrupts and do other */
    /* cyclic tasks here                 */
    ...
    Counter+=InterruptPeriod;
    if(ExitRequired) break;
  }
}

首先我指定 CPU L期灯 (Counter)，以及指令位址灯 (PC)



Counter=InterruptPeriod; 
PC=InitialPC; 

Counter o了到下一次系y中囿生，剩多少 CPU L期。注意 Counter ^其，系y中嗖槐厝话l生。你可以利用他硖理其事情：像是r同步，更新幕的呙榫等。等等，我@些。PC to了CPU 哪w位址，x取下次的绦械闹噶睢

在我o@些O定初始值之後，然後_始M入主圈：




for(;;)
{

主圈也可以成@樱

while(CPUIsRunning)
{

CPUIsRunning 是布林值，@有好，你可以在任何r候，O CPUIsRunning＝0，斫K止主圈。然而在每圈z查@担花不少的 CPU，而我量p少花M CPU。同r，不要成下面@幼樱

while(1)
{

因檫@，g器a生代a，去z查 1  "真" 或 "假"，你不希望在主圈的每圈，都去绦羞@多N的幼鳌

F在我在主圈龋第一件事，就是去x下一绦写a，然後修改程式位址灯鳌

OpCode=Memory[PC++];

注意，@是最易的方式，砟Mx取w，但K非永h可行。更通用的方式，泶嫒∮w，稍後提到。

在提取操作a後， CPU L期灯鳎扣掉@指令所需的L期怠

Counter-=Cycles[OpCode];

Cycles[] 表确诺氖敲操作a，所需要的L期怠Ｒ特e注意，有些指令（例如l件式跳S，或是呼叫副程式），需要的L期担是跟操作後面o接的刀印＿@可以在绦兄噶畲ar{整。

F在是解g操作a，然後跟著绦械r候了：

switch(OpCode)
{

有一e`的^念，J switch ⑹鍪]有效率的，因被g成 if () ...... else if () ........ ⑹觥＿@只有在 case 盗亢苌俚 switch ⑹觯才被@泳g。有 100 到 200  case 的r候，switch ⑹鐾ǔ被翻g成 jump 表格，jump 表格，其U有效率的。

有其他煞N替代方案，可以用斫庾g操作a。第一N方法，是建一函式表，然後呼叫的函式。@N方式，比用 switch() ]效率，因楹艚泻式，有~外的_N。第二N方式，是建一位址的表格，然後使用 goto ⑹觥＿@N方式，稍比用 switch() 有效率一c，但@N方式，只m合用在g器支援未A定位址表格。其他的g器，不允S你@佣x表格。

在成功解gK绦幸操作a後，@r候去z查有]有任何系y中囿生。@r候，你也可以绦腥魏涡枰跟系yr同步的工作。

if(Counter<=0)
{  
  /* Check for interrupts and do other hardware emulation here */
  ...
  Counter+=InterruptPeriod;
  if(ExitRequired) break;
}

有PL期性的工作，後面提到。

注意，我K非直接指定 Counter=InterruptPeriod，而是绦 Counter+=InterruptPeriod，@L期的算更精_，因橛r候，Counter 成怠

同r，注意@

if(ExitRequired) break;

@⑹鋈绻在每圈都绦校成本太高，所以只有在中囿生r才z查。@泳涂梢栽 ExitRequired=1 r，停止模M，但又不花太大的成本。
-------------------------------------------------------------------------
如何存取被模M的w？

模Mw存取最蔚姆绞剑就是把它成一平的位元M或字元M列。如此，存取w，就是一件微不足道的事情：




  Data=Memory[Address1]; /* Read from Address1 */
  Memory[Address2]=Data; /* Write to Address2  */

@N易的作法，K非永h可行，原因如下：
分式的w
w空g，可能被切成小K，成可以切Q的，就是所^的 banks。例如常的，小w位址空g（ 64 KB），所使用的U充w。
映射的w
@Kw空g，可以用不同的位址泶嫒　＠如你Y料到位址 $4000，然後你在位址$6000，及位址 $8000，你也可以x到。
ROM 的x取保o
有些存到卡A的w（例如 MSX 的[颍，就算你到 ROM，回鞒晒Γ事上 ROM 上的Y料也不改。@N做，是榱俗鲕w保o。榱俗@拥能w，可以在你的模M器\行，你需要把 ROM O成唯x。
w映射到 I/O
系y可能有 I/O b置，映射到w位址。存取@拥挠w位址，a生特殊效果，所以必被追。
要成功理上述}，我引M函式：

  Data=ReadMemory(Address1);  /* Read from Address1 */
  WriteMemory(Address2,Data); /* Write to Address2  */

所有特殊的理，包括w分，w映射，I/O 的理，等等，都在函式忍理。

ReadMemory() 跟 WriteMemory() δM器造成很大的 CPU ，因樗绦械姆浅ｎl繁。因此
@些函式必得越有效率越好。@e有一存取分式w的例子：

static inline byte ReadMemory(register word Address)
{
  return(MemoryPage[Address>>13][Address&0x1FFF]);
}

static inline void WriteMemory(register word Address,register byte Value)
{
  MemoryPage[Address>>13][Address&0x1FFF]=Value;
}
注意那 inline PI字，它指示g器，直接把@些函式a，直接插入程式中，以取代函式呼叫。如果你的g器，不支援 inline 或是 _inline，著改把@些函式，宣告成 static，有些g器（例如 Watcom C）最佳化r，把短的函式，成 inline 函式。

同r要住，通常 ReadMemory() 的呼叫次担是 WriteMemory() 的好妆丁Ｋ以量把程式a放到 WriteMemory()， ReadMemory() 保持巍

P於w映射的一小]：

之前f^，被映射的w，入一位址，可以在其他位址x取。@功能，可以做在 ReadMemory()，但是通常我不@幼觯因 ReadMemory() 比 WriteMemory() 更l繁被呼叫。更有效率的方式，是做w映射到 WriteMemory()函式。




-------------------------------------------------------------------------
L期性的\作有哪些？

L期性的\作，是被模M的C器，固定一段rg，就绦械墓ぷ鳎例如：
幕更新
VBlank 跟 HBlank 系y中
更新r
更新音
更新IP跟uUB
其他
榱艘模M@拥倪\作，你要替它上固定的L期。例如 CPU 假O以 2.5 MHz，K且以 50 Hz 更新@示（PAL 系y），所以 VBlank 系y中啵就每 5000 CPU L期，l生一次。

    2500000/50 = 50000 CPU cycles

F在，假O整幕是（包含 VBlank）是 256 l呙榫，H上只有 212 l@示（44 l在 VBlank），我得到一l呙榫 195  CPU L期，更新一次。

     50000/256 ~= 195 CPU cyles

然後，我a生一 VBlank 系y中啵然後在 VBlank 期g不做任何事情。

     (256-212)*50000/256 = 44*50000/256 ~= 8594 CPU cycles

小心算每L期性\作所需的 CPU L期，然後使用他的最大公s担作橹z查的L期，然後定o每L期性\作。

-------------------------------------------------------------------------
如何最佳化 C 程式a？

首先，很多绦行率的增M，只要xg器的gx，就有了。根我的，下面的gx，可以o你的最佳的绦兴俣龋




Watcom C++      -oneatx -zp4 -5r -fp3
GNU C++         -O3 -fomit-frame-pointer
Borland C++

如果你lF，@三g器，更好的最佳化担或是其他的g器的最佳化担我知道。
一些P於把圈平的P
m然f，把圈平的@最佳化x，看起硎怯杏玫摹＿@x，把短的圈，平成性的⑹觥５我的告V我，_⑦@x，绦行率K不提升太大，反而在某些情r下，程式反而出F常。

最佳化 C 程式a，比x窬g器x，y搞。跟绦心愕某淌降 CPU 有很大PS。有一些通用的t，可以m用在所有 CPU。但e把它成真理。
使用分析程式
用分析工具绦心愕某淌剑ǖ谝就想到 GPROF），或S可以lF你]岩傻纳衿媸虑椤ＤlF毫不起眼的程式，l繁的被绦校拖慢整程式。最佳化@些程式a，或是用M合Z言改，可以你的程式绦行率w耀。
不要用 C++
不要用任何非用 C++ 不可的架。C++ 跟 C 比起恚~外的_N比^大。
整档男e
量用你的 CPU 支持的整敌e。e例 int Ρ short 或 long，@p少g器a生不同整敌e的DQ。
捍嫫髋渲
量p少在程式^K配置太多担K且宣告他 register （大部分的g器已自影炎底成 register）。特e是有很多通用捍嫫鞯 CPU （PowerPC）@荩就比有捍嫫鳎Intel 8086）淼。
平小圈
如果你好有小圈绦泻状危把小圈平成性绦械某淌剑是好主意。φ涨懊嫣岬降木g器自平x。
算g移位 vs. 乘除法
量用算g移位，如果你乘或除一凳 2 的 n 次方（J/128==J>>7），算g移位在大多档 CPU 都比^快。另外用位元的 & 砬箴N担J%128==J&0x7F）。


-------------------------------------------------------------------------
什N是高低字序？

所有的 CPU 通常都根它如何Υ尜Y料到w，分等。除了非常特殊的N，^大多档 CPU 分成等：
High-endian CPU 先存放 higher byte of word。例如，在@拥 CPU 你存放 0x12345678，w的热L像@樱
                      0  1  2  3
                     +--+--+--+--+
                     |12|34|56|78|
                     +--+--+--+--+
Low-endian CPU 先存放 lower byte of word。上述了例子，w热看起硗耆不一印
                       0  1  2  3
                     +--+--+--+--+
                     |78|56|34|12|
                     +--+--+--+--+
典型 High-endian 的 CPU 有 6809，摩_托拉 680x0 系列，PowerPC，及N的 SPARC。Low-Endian 的 CPU 有 6502，及其後代 65816，及 zilog Z80，^大多 Intel CPU （8086，8088），DEC alpha 等。

我模M器r，必注意到，你模M的 CPU，及绦心愕哪M器的 CPU 的高低字。e例，我想要模M low-endian 的 Z80，Z80 先存 lower byte of word。如果你用的也是 low-endian 的 CPU，例如 intel 8006，那N完全不需要特e理。但是如果你用的是 high-endian 的 CPU，例如 PowerPC，@r候，要存放 16 bit 的 Z80 Y料到w，就有}。如果你的程式，必煞N高低字序的 CPU 都能跑，}就更}s了。

一N解高低字序的作法如下：


typedef union
{

  short W;        /* Word access */

  struct          /* Byte access... */
  {
#ifdef LOW_ENDIAN
    byte l,h;     /* ...in low-endian architecture */
#else
    byte h,l;     /* ...in high-endian architecture */
#endif
  } B;

} word;                     

可以看到，可以用 w 存取整字。而每次如果你需要存取e byte，用 B.l 及 B.w，高低位元M。

如果你的程式，要在跨平台g，在程式_始绦星埃你也S想要y，是否g有O定正_的 endian 旗恕＿@e有如何y的程式a。

int *T;

T=(int *)"\01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
if(*T==1) printf("This machine is high-endian.\n");
else      printf("This machine is low-endian.\n");


-------------------------------------------------------------------------
如何程式具可移植性？

尚未撰。


-------------------------------------------------------------------------
楹挝乙模M化我的程式？

大多档碾X系y，是由K比^大的晶片所M成，各自绦幸徊糠值南到y功能。有 CPU，@示控制器，音a生器，及其他。有些晶片，有自己的w，及周的硬w。

一典型的模M器，重F原有的系yO，K做每子系y的功能，在不同的模M。@幼觯首先除e比^容易，因}被立在各自的模Me。其次模M化，可以你在e的模M器，重}使用你的模M。X的硬w，其驶成度很高，你可以在不同型的X，lF相同的 CPU，相同的@示控制器。槟晶片，模M化一次模M的程式，比你每次都重淼娜菀住